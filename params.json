{"name":"Driving-simulator","tagline":"A Driving simulator using HERE Maps API","body":"<!-- (c) Abid Mohammed 2015 -->\r\n<!-- Apache Licence -->\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Driving Simulator</title>\r\n    <style type=\"text/css\">\r\n        body {\r\n            width: 100%;\r\n            height: 100%;\r\n            margin: 0;\r\n        }\r\n    </style>\r\n    <script type=\"text/javascript\" charset=\"UTF-8\" src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\"></script>\r\n    <script type=\"text/javascript\" charset=\"UTF-8\" src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\"></script>\r\n    <script type=\"text/javascript\" charset=\"UTF-8\" src=\"https://js.api.here.com/v3/3.0/mapsjs-ui.js\"></script>\r\n    <script type=\"text/javascript\" charset=\"UTF-8\" src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\"></script>\r\n    <script type=\"text/javascript\" charset=\"utf-8\" src=\"http://js.api.here.com/v3/3.0/mapsjs-pano.js\"></script>\r\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js\"></script>\r\n</head>\r\n<body>\r\n<div id=\"map\" style=\"width: 100%\"/>\r\n<canvas id=\"vehicleMarkerCanvas\" width=\"28\" height=\"28\" style=\"display: none;\"></canvas>\r\n<script>\r\n    function moveMapTo(map, latLong, zoomLevel) {\r\n        map.setCenter(latLong);\r\n        map.setZoom(zoomLevel);\r\n    }\r\n    function enableTrafficInfo() {\r\n        map.setBaseLayer(defaultLayers.satellite.traffic);\r\n        map.addLayer(defaultLayers.incidents);\r\n    }\r\n\r\n    var platform = new H.service.Platform({\r\n        app_id: 'YhvbJSgCHhXzWMatvfl1',\r\n        app_code: 'WrD3YoZ2yXjYrBQRDQPUFQ',\r\n        useCIT: true,\r\n        useHTTPS: false\r\n    });\r\n\r\n    $(\"#map\").height($(document).height());\r\n    var zoomLevel = 15;\r\n    var defaultLayers = platform.createDefaultLayers();\r\n    var map = new H.Map(document.getElementById('map'), defaultLayers.satellite.map);\r\n    var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\r\n    var ui = H.ui.UI.createDefault(map, defaultLayers);\r\n    moveMapTo(map, {lat: 32.673764, lng: -117.240591}, zoomLevel);\r\n    enableTrafficInfo();\r\n    var startLocation = '41.890922,-87.616806';\r\n    var endLocation = '41.984185,-87.652602';\r\n    $(document).ready(function () {\r\n        calculateRouteFromAtoB();\r\n    });\r\n\r\n    $(window).on('resize', function () {\r\n        location.reload();\r\n    });\r\n    var vehicleMarker = createVehicleMarkerCanvas(\"vehicleMarkerCanvas\");\r\n\r\n    var activeMarker;\r\n    var currentDrivingLocationIndex = 0;\r\n    var fineDist = 10; //Meters\r\n    var driveInterval = 100; //Millisecond\r\n    var vehicleSpeed = 500;\r\n    var activeIntervalTimer;\r\n    var drivingRoute;\r\n    var activeMarker;\r\n    var dotIcon = new H.map.Icon(vehicleMarker, {anchor: {x: 14, y: 14}});\r\n\r\n    function clearGlobals(resetSpeed) {\r\n        clearTimeout(activeIntervalTimer);\r\n        currentDrivingLocationIndex = 0;\r\n        activeMarker = null;\r\n        drivingRoute = null;\r\n        activeIntervalTimer = null;\r\n    }\r\n\r\n    function driveThroughRoute(route) {\r\n        try {\r\n            drivingRoute = convertRouteIntoFinerLatLngs(route, fineDist);\r\n            driveInterval = calcTimeInMilliSec(vehicleSpeed, fineDist * 0.000621371);\r\n            activeIntervalTimer = setInterval(function () {\r\n                addAndRemoveMarker()\r\n            }, driveInterval);\r\n        } catch (err) {\r\n            if (activeIntervalTimer) {\r\n                clearTimeout(activeIntervalTimer);\r\n            }\r\n            console.error(err);\r\n        }\r\n    }\r\n\r\n    function addAndRemoveMarker() {\r\n        var currentLocation = drivingRoute[currentDrivingLocationIndex];\r\n        var marker;\r\n        if (currentLocation.point) {\r\n            marker = new H.map.Marker({\r\n                lat: currentLocation.point.lat,\r\n                lng: currentLocation.point.lon\r\n            }, {icon: dotIcon});\r\n        } else {\r\n            marker = new H.map.Marker({lat: currentLocation.lat, lng: currentLocation.lon}, {icon: dotIcon});\r\n        }\r\n        map.addObject(marker);\r\n        map.setCenter(marker.getPosition());\r\n        if (activeMarker) {\r\n            map.removeObject(activeMarker);\r\n        }\r\n        activeMarker = marker;\r\n        map.setZoom(16);\r\n        currentDrivingLocationIndex++;\r\n        if (currentDrivingLocationIndex == drivingRoute.length - 1) {\r\n            clearGlobals();\r\n        }\r\n    }\r\n\r\n    function pauseDriving() {\r\n        clearTimeout(activeIntervalTimer);\r\n    }\r\n\r\n    function calculateRouteFromAtoB() {\r\n        var router = platform.getRoutingService(),\r\n                routeRequestParams = {\r\n                    mode: 'fastest;car',\r\n                    representation: 'display',\r\n                    routeattributes: 'waypoints,summary,shape,legs',\r\n                    maneuverattributes: 'direction,action',\r\n                    waypoint0: startLocation,\r\n                    waypoint1: endLocation\r\n                };\r\n        router.calculateRoute(\r\n                routeRequestParams,\r\n                onRouteSuccess,\r\n                onError\r\n        );\r\n    }\r\n\r\n    function onRouteSuccess(result) {\r\n        var route = result.response.route[0];\r\n        addRouteShapeToMap(route);\r\n        driveThroughRoute(route);\r\n    }\r\n\r\n    function onError(error) {\r\n        console.log('Error getting route!');\r\n    }\r\n\r\n    function addRouteShapeToMap(route) {\r\n        var strip = new H.geo.Strip(),\r\n                routeShape = route.shape,\r\n                polyline;\r\n        routeShape.forEach(function (shapePoint) {\r\n            var parts = shapePoint.split(',');\r\n            strip.pushLatLngAlt(parts[0], parts[1]);\r\n        });\r\n        polyline = new H.map.Polyline(strip, {\r\n            style: {\r\n                lineWidth: 4,\r\n                strokeColor: 'rgba(0, 128, 255, 0.7)'\r\n            }\r\n        });\r\n        map.addObject(polyline);\r\n        map.setViewBounds(polyline.getBounds(), true);\r\n    }\r\n\r\n    /**\r\n     * Put all JS dependencies here\r\n     */\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n    /*  Geodesy representation conversion functions                       (c) Chris Veness 2002-2015  */\r\n    /*   - www.movable-type.co.uk/scripts/latlong.html                                   MIT Licence  */\r\n    /*                                                                                                */\r\n    /*  Sample usage:                                                                                 */\r\n    /*    var lat = Dms.parseDMS('51° 28′ 40.12″ N');                                                 */\r\n    /*    var lon = Dms.parseDMS('000° 00′ 05.31″ W');                                                */\r\n    /*    var p1 = new LatLon(lat, lon);                                                              */\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Tools for converting between numeric degrees and degrees / minutes / seconds.\r\n     *\r\n     * @namespace\r\n     */\r\n    var Dms = {};\r\n\r\n\r\n    // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033\r\n\r\n\r\n    /**\r\n     * Parses string representing degrees/minutes/seconds into numeric degrees.\r\n     *\r\n     * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\r\n     * suffixed by compass direction (NSEW). A variety of separators are accepted (eg 3° 37′ 09″W).\r\n     * Seconds and minutes may be omitted.\r\n     *\r\n     * @param   {string|number} dmsStr - Degrees or deg/min/sec in variety of formats.\r\n     * @returns {number} Degrees as decimal number.\r\n     */\r\n    Dms.parseDMS = function (dmsStr) {\r\n        // check for signed decimal degrees without NSEW, if so return it directly\r\n        if (typeof dmsStr == 'number' && isFinite(dmsStr)) return Number(dmsStr);\r\n\r\n        // strip off any sign or compass dir'n & split out separate d/m/s\r\n        var dms = String(dmsStr).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);\r\n        if (dms[dms.length - 1] == '') dms.splice(dms.length - 1);  // from trailing symbol\r\n\r\n        if (dms == '') return NaN;\r\n\r\n        // and convert to decimal degrees...\r\n        var deg;\r\n        switch (dms.length) {\r\n            case 3:  // interpret 3-part result as d/m/s\r\n                deg = dms[0] / 1 + dms[1] / 60 + dms[2] / 3600;\r\n                break;\r\n            case 2:  // interpret 2-part result as d/m\r\n                deg = dms[0] / 1 + dms[1] / 60;\r\n                break;\r\n            case 1:  // just d (possibly decimal) or non-separated dddmmss\r\n                deg = dms[0];\r\n                // check for fixed-width unseparated format eg 0033709W\r\n                //if (/[NS]/i.test(dmsStr)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees\r\n                //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;\r\n                break;\r\n            default:\r\n                return NaN;\r\n        }\r\n        if (/^-|[WS]$/i.test(dmsStr.trim())) deg = -deg; // take '-', west and south as -ve\r\n\r\n        return Number(deg);\r\n    };\r\n\r\n\r\n    /**\r\n     * Converts decimal degrees to deg/min/sec format\r\n     *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass\r\n     *    direction is added.\r\n     *\r\n     * @private\r\n     * @param   {number} deg - Degrees to be formatted as specified.\r\n     * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n     * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n     */\r\n    Dms.toDMS = function (deg, format, dp) {\r\n        if (isNaN(deg)) return null;  // give up here if we can't make a number from deg\r\n\r\n        // default values\r\n        if (format === undefined) format = 'dms';\r\n        if (dp === undefined) {\r\n            switch (format) {\r\n                case 'd':\r\n                case 'deg':\r\n                    dp = 4;\r\n                    break;\r\n                case 'dm':\r\n                case 'deg+min':\r\n                    dp = 2;\r\n                    break;\r\n                case 'dms':\r\n                case 'deg+min+sec':\r\n                    dp = 0;\r\n                    break;\r\n                default:\r\n                    format = 'dms';\r\n                    dp = 0;  // be forgiving on invalid format\r\n            }\r\n        }\r\n\r\n        deg = Math.abs(deg);  // (unsigned result ready for appending compass dir'n)\r\n\r\n        var dms, d, m, s;\r\n        switch (format) {\r\n            default: // invalid format spec!\r\n            case 'd':\r\n            case 'deg':\r\n                d = deg.toFixed(dp);    // round degrees\r\n                if (d < 100) d = '0' + d; // pad with leading zeros\r\n                if (d < 10) d = '0' + d;\r\n                dms = d + '°';\r\n                break;\r\n            case 'dm':\r\n            case 'deg+min':\r\n                var min = (deg * 60).toFixed(dp); // convert degrees to minutes & round\r\n                d = Math.floor(min / 60);       // get component deg/min\r\n                m = (min % 60).toFixed(dp);     // pad with trailing zeros\r\n                if (d < 100) d = '0' + d;         // pad with leading zeros\r\n                if (d < 10) d = '0' + d;\r\n                if (m < 10) m = '0' + m;\r\n                dms = d + '°' + m + '′';\r\n                break;\r\n            case 'dms':\r\n            case 'deg+min+sec':\r\n                var sec = (deg * 3600).toFixed(dp); // convert degrees to seconds & round\r\n                d = Math.floor(sec / 3600);       // get component deg/min/sec\r\n                m = Math.floor(sec / 60) % 60;\r\n                s = (sec % 60).toFixed(dp);       // pad with trailing zeros\r\n                if (d < 100) d = '0' + d;           // pad with leading zeros\r\n                if (d < 10) d = '0' + d;\r\n                if (m < 10) m = '0' + m;\r\n                if (s < 10) s = '0' + s;\r\n                dms = d + '°' + m + '′' + s + '″';\r\n                break;\r\n        }\r\n\r\n        return dms;\r\n    };\r\n\r\n\r\n    /**\r\n     * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).\r\n     *\r\n     * @param   {number} deg - Degrees to be formatted as specified.\r\n     * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n     * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n     */\r\n    Dms.toLat = function (deg, format, dp) {\r\n        var lat = Dms.toDMS(deg, format, dp);\r\n        return lat === null ? '–' : lat.slice(1) + (deg < 0 ? 'S' : 'N');  // knock off initial '0' for lat!\r\n    };\r\n\r\n\r\n    /**\r\n     * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W)\r\n     *\r\n     * @param   {number} deg - Degrees to be formatted as specified.\r\n     * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n     * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n     */\r\n    Dms.toLon = function (deg, format, dp) {\r\n        var lon = Dms.toDMS(deg, format, dp);\r\n        return lon === null ? '–' : lon + (deg < 0 ? 'W' : 'E');\r\n    };\r\n\r\n\r\n    /**\r\n     * Converts numeric degrees to deg/min/sec as a bearing (0°..360°)\r\n     *\r\n     * @param   {number} deg - Degrees to be formatted as specified.\r\n     * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n     * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n     */\r\n    Dms.toBrng = function (deg, format, dp) {\r\n        deg = (Number(deg) + 360) % 360;  // normalise -ve values to 180°..360°\r\n        var brng = Dms.toDMS(deg, format, dp);\r\n        return brng === null ? '–' : brng.replace('360', '0');  // just in case rounding took us up to 360°!\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns compass point (to given precision) for supplied bearing.\r\n     *\r\n     * @param   {number} bearing - Bearing in degrees from north.\r\n     * @param   {number} [precision=3] - Precision (cardinal / intercardinal / secondary-intercardinal).\r\n     * @returns {string} Compass point for supplied bearing.\r\n     *\r\n     * @example\r\n     *   var point = Dms.compassPoint(24);    // point = 'NNE'\r\n     *   var point = Dms.compassPoint(24, 1); // point = 'N'\r\n     */\r\n    Dms.compassPoint = function (bearing, precision) {\r\n        if (precision === undefined) precision = 3;\r\n        // note precision = max length of compass point; it could be extended to 4 for quarter-winds\r\n        // (eg NEbN), but I think they are little used\r\n\r\n        bearing = ((bearing % 360) + 360) % 360; // normalise to 0..360\r\n\r\n        var point;\r\n\r\n        switch (precision) {\r\n            case 1: // 4 compass points\r\n                switch (Math.round(bearing * 4 / 360) % 4) {\r\n                    case 0:\r\n                        point = 'N';\r\n                        break;\r\n                    case 1:\r\n                        point = 'E';\r\n                        break;\r\n                    case 2:\r\n                        point = 'S';\r\n                        break;\r\n                    case 3:\r\n                        point = 'W';\r\n                        break;\r\n                }\r\n                break;\r\n            case 2: // 8 compass points\r\n                switch (Math.round(bearing * 8 / 360) % 8) {\r\n                    case 0:\r\n                        point = 'N';\r\n                        break;\r\n                    case 1:\r\n                        point = 'NE';\r\n                        break;\r\n                    case 2:\r\n                        point = 'E';\r\n                        break;\r\n                    case 3:\r\n                        point = 'SE';\r\n                        break;\r\n                    case 4:\r\n                        point = 'S';\r\n                        break;\r\n                    case 5:\r\n                        point = 'SW';\r\n                        break;\r\n                    case 6:\r\n                        point = 'W';\r\n                        break;\r\n                    case 7:\r\n                        point = 'NW';\r\n                        break;\r\n                }\r\n                break;\r\n            case 3: // 16 compass points\r\n                switch (Math.round(bearing * 16 / 360) % 16) {\r\n                    case  0:\r\n                        point = 'N';\r\n                        break;\r\n                    case  1:\r\n                        point = 'NNE';\r\n                        break;\r\n                    case  2:\r\n                        point = 'NE';\r\n                        break;\r\n                    case  3:\r\n                        point = 'ENE';\r\n                        break;\r\n                    case  4:\r\n                        point = 'E';\r\n                        break;\r\n                    case  5:\r\n                        point = 'ESE';\r\n                        break;\r\n                    case  6:\r\n                        point = 'SE';\r\n                        break;\r\n                    case  7:\r\n                        point = 'SSE';\r\n                        break;\r\n                    case  8:\r\n                        point = 'S';\r\n                        break;\r\n                    case  9:\r\n                        point = 'SSW';\r\n                        break;\r\n                    case 10:\r\n                        point = 'SW';\r\n                        break;\r\n                    case 11:\r\n                        point = 'WSW';\r\n                        break;\r\n                    case 12:\r\n                        point = 'W';\r\n                        break;\r\n                    case 13:\r\n                        point = 'WNW';\r\n                        break;\r\n                    case 14:\r\n                        point = 'NW';\r\n                        break;\r\n                    case 15:\r\n                        point = 'NNW';\r\n                        break;\r\n                }\r\n                break;\r\n            default:\r\n                throw new RangeError('Precision must be between 1 and 3');\r\n        }\r\n\r\n        return point;\r\n    };\r\n\r\n\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n\r\n    /** Polyfill String.trim for old browsers\r\n     *  (q.v. blog.stevenlevithan.com/archives/faster-trim-javascript) */\r\n    if (String.prototype.trim === undefined) {\r\n        String.prototype.trim = function () {\r\n            return String(this).replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\r\n        };\r\n    }\r\n\r\n\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n    if (typeof module != 'undefined' && module.exports) module.exports = Dms; // CommonJS (Node)\r\n    if (typeof define == 'function' && define.amd) define([], function () {\r\n        return Dms;\r\n    }); // AMD\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n    /* Geodesy tools for an ellipsoidal earth model         (c) Chris Veness 2005-2015 / MIT Licence  */\r\n    /*                                                                                                */\r\n    /* Includes methods for converting lat/lon coordinates between different coordinate systems.      */\r\n    /*   - www.movable-type.co.uk/scripts/latlong-convert-coords.html                                 */\r\n    /*                                                                                                */\r\n    /*  Usage: to eg convert WGS 84 coordinate to OSGB coordinate:                                    */\r\n    /*   - var wgs84 = new LatLon(latWGS84, lonWGS84, LatLon.datum.WGS84);                            */\r\n    /*   - var osgb = wgs84.convertDatum(LatLon.datum.OSGB36);                                        */\r\n    /*   - var latOSGB = osgb.lat, lonOSGB = osgb.lon;                                                */\r\n    /*                                                                                                */\r\n    /*  q.v. Ordnance Survey 'A guide to coordinate systems in Great Britain' Section 6               */\r\n    /*   - www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf           */\r\n    /*                                                                                                */\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n    'use strict';\r\n    if (typeof module != 'undefined' && module.exports) var Vector3d = require('./vector3d.js'); // CommonJS (Node)\r\n    if (typeof module != 'undefined' && module.exports) var Dms = require('./dms.js'); // CommonJS (Node)\r\n\r\n\r\n    /**\r\n     * Creates lat/lon (polar) point with latitude & longitude values, on a specified datum.\r\n     *\r\n     * @classdesc Library of geodesy functions for operations on an ellipsoidal earth model.\r\n     * @requires Dms from 'dms.js'\r\n     *\r\n     * @constructor\r\n     * @param {number}       lat - Geodetic latitude in degrees.\r\n     * @param {number}       lon - Longitude in degrees.\r\n     * @param {LatLon.datum} [datum=WGS84] - Datum this point is defined within.\r\n     *\r\n     * @example\r\n     *     var p1 = new LatLon(51.4778, -0.0016, LatLon.datum.WGS84);\r\n     */\r\n    function LatLon(lat, lon, datum) {\r\n        // allow instantiation without 'new'\r\n        if (!(this instanceof LatLon)) return new LatLon(lat, lon, datum);\r\n\r\n        if (datum === undefined) datum = LatLon.datum.WGS84;\r\n\r\n        this.lat = Number(lat);\r\n        this.lon = Number(lon);\r\n        this.datum = datum;\r\n    }\r\n\r\n\r\n    /**\r\n     * Ellipsoid parameters; major axis (a), minor axis (b), and flattening (f) for each ellipsoid.\r\n     */\r\n    LatLon.ellipsoid = {\r\n        WGS84: {a: 6378137, b: 6356752.31425, f: 1 / 298.257223563},\r\n        GRS80: {a: 6378137, b: 6356752.31414, f: 1 / 298.257222101},\r\n        Airy1830: {a: 6377563.396, b: 6356256.909, f: 1 / 299.3249646},\r\n        AiryModified: {a: 6377340.189, b: 6356034.448, f: 1 / 299.3249646},\r\n        Intl1924: {a: 6378388, b: 6356911.946, f: 1 / 297},\r\n        Bessel1841: {a: 6377397.155, b: 6356078.963, f: 1 / 299.152815351},\r\n    };\r\n\r\n    /**\r\n     * Datums; with associated *ellipsoid* and Helmert *transform* parameters to convert from WGS 84\r\n     * into given datum.\r\n     *\r\n     * More are available from earth-info.nga.mil/GandG/coordsys/datums/NATO_DT.pdf,\r\n     * www.fieldenmaps.info/cconv/web/cconv_params.js\r\n     */\r\n    LatLon.datum = {\r\n        /* eslint key-spacing: 0, comma-dangle: 0 */\r\n        WGS84: {\r\n            ellipsoid: LatLon.ellipsoid.WGS84,\r\n            transform: {\r\n                tx: 0.0, ty: 0.0, tz: 0.0,    // m\r\n                rx: 0.0, ry: 0.0, rz: 0.0,    // sec\r\n                s: 0.0\r\n            }                                  // ppm\r\n        },\r\n        NAD83: { // (2009); functionally ≡ WGS84 - www.uvm.edu/giv/resources/WGS84_NAD83.pdf\r\n            ellipsoid: LatLon.ellipsoid.GRS80,\r\n            transform: {\r\n                tx: 1.004, ty: -1.910, tz: -0.515,  // m\r\n                rx: 0.0267, ry: 0.00034, rz: 0.011,  // sec\r\n                s: -0.0015\r\n            }                               // ppm\r\n        }, // note: if you *really* need to convert WGS84<->NAD83, you need more knowledge than this!\r\n        OSGB36: { // www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf\r\n            ellipsoid: LatLon.ellipsoid.Airy1830,\r\n            transform: {\r\n                tx: -446.448, ty: 125.157, tz: -542.060,  // m\r\n                rx: -0.1502, ry: -0.2470, rz: -0.8421, // sec\r\n                s: 20.4894\r\n            }                               // ppm\r\n        },\r\n        ED50: { // og.decc.gov.uk/en/olgs/cms/pons_and_cop/pons/pon4/pon4.aspx\r\n            ellipsoid: LatLon.ellipsoid.Intl1924,\r\n            transform: {\r\n                tx: 89.5, ty: 93.8, tz: 123.1,    // m\r\n                rx: 0.0, ry: 0.0, rz: 0.156,  // sec\r\n                s: -1.2\r\n            }                                  // ppm\r\n        },\r\n        Irl1975: { // osi.ie/OSI/media/OSI/Content/Publications/transformations_booklet.pdf\r\n            ellipsoid: LatLon.ellipsoid.AiryModified,\r\n            transform: {\r\n                tx: -482.530, ty: 130.596, tz: -564.557,  // m\r\n                rx: -1.042, ry: -0.214, rz: -0.631,  // sec\r\n                s: -8.150\r\n            }                                // ppm\r\n        }, // note: many sources have opposite sign to rotations - to be checked!\r\n        TokyoJapan: { // www.geocachingtoolbox.com?page=datumEllipsoidDetails\r\n            ellipsoid: LatLon.ellipsoid.Bessel1841,\r\n            transform: {\r\n                tx: 148, ty: -507, tz: -685,      // m\r\n                rx: 0, ry: 0, rz: 0,      // sec\r\n                s: 0\r\n            }                                    // ppm\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ lat/lon coordinate to new coordinate system.\r\n     *\r\n     * @param   {LatLon.datum} toDatum - Datum this coordinate is to be converted to.\r\n     * @returns {LatLon} This point converted to new datum.\r\n     *\r\n     * @example\r\n     *     var pWGS84 = new LatLon(51.4778, -0.0016, LatLon.datum.WGS84);\r\n     *     var pOSGB = pWGS84.convertDatum(LatLon.datum.OSGB36); // pOSGB.toString(): 51.4773°N, 000.0000°E\r\n     */\r\n    LatLon.prototype.convertDatum = function (toDatum) {\r\n        var oldLatLon = this;\r\n        var transform;\r\n\r\n        if (oldLatLon.datum == LatLon.datum.WGS84) {\r\n            // converting from WGS 84\r\n            transform = toDatum.transform;\r\n        }\r\n        if (toDatum == LatLon.datum.WGS84) {\r\n            // converting to WGS 84; use inverse transform (don't overwrite original!)\r\n            transform = {};\r\n            for (var param in oldLatLon.datum.transform) {\r\n                if (oldLatLon.datum.transform.hasOwnProperty(param)) {\r\n                    transform[param] = -oldLatLon.datum.transform[param];\r\n                }\r\n            }\r\n        }\r\n        if (transform === undefined) {\r\n            // neither this.datum nor toDatum are WGS84: convert this to WGS84 first\r\n            oldLatLon = this.convertDatum(LatLon.datum.WGS84);\r\n            transform = toDatum.transform;\r\n        }\r\n\r\n        var cartesian = oldLatLon.toCartesian();         // convert polar to cartesian...\r\n        cartesian = cartesian.applyTransform(transform); // ...apply transform...\r\n        var newLatLon = cartesian.toLatLonE(toDatum);    // ...and convert cartesian to polar\r\n\r\n        return newLatLon;\r\n    };\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric) cartesian\r\n     * (x/y/z) coordinates.\r\n     *\r\n     * @returns {Vector3d} Vector pointing to lat/lon point, with x, y, z in metres from earth centre.\r\n     */\r\n    LatLon.prototype.toCartesian = function () {\r\n        var φ = this.lat.toRadians(), λ = this.lon.toRadians();\r\n        var h = 0; // height above ellipsoid - not currently used\r\n        var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b;\r\n\r\n        var sinφ = Math.sin(φ), cosφ = Math.cos(φ);\r\n        var sinλ = Math.sin(λ), cosλ = Math.cos(λ);\r\n\r\n        var eSq = (a * a - b * b) / (a * a);\r\n        var ν = a / Math.sqrt(1 - eSq * sinφ * sinφ);\r\n\r\n        var x = (ν + h) * cosφ * cosλ;\r\n        var y = (ν + h) * cosφ * sinλ;\r\n        var z = ((1 - eSq) * ν + h) * sinφ;\r\n\r\n        var point = new Vector3d(x, y, z);\r\n\r\n        return point;\r\n    };\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ (geocentric) cartesian (x/y/z) point to (ellipsoidal geodetic) latitude/longitude\r\n     * coordinates on specified datum.\r\n     *\r\n     * Uses Bowring’s (1985) formulation for μm precision.\r\n     *\r\n     * @param {LatLon.datum.transform} datum - Datum to use when converting point.\r\n     */\r\n    Vector3d.prototype.toLatLonE = function (datum) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var a = datum.ellipsoid.a, b = datum.ellipsoid.b;\r\n\r\n        var e2 = (a * a - b * b) / (a * a); // 1st eccentricity squared\r\n        var ε2 = (a * a - b * b) / (b * b); // 2nd eccentricity squared\r\n        var p = Math.sqrt(x * x + y * y); // distance from minor axis\r\n        var R = Math.sqrt(p * p + z * z); // polar radius\r\n\r\n        // parametric latitude (Bowring eqn 17, replacing tanβ = z·a / p·b)\r\n        var tanβ = (b * z) / (a * p) * (1 + ε2 * b / R);\r\n        var sinβ = tanβ / Math.sqrt(1 + tanβ * tanβ);\r\n        var cosβ = sinβ / tanβ;\r\n\r\n        // geodetic latitude (Bowring eqn 18)\r\n        var φ = Math.atan2(z + ε2 * b * sinβ * sinβ * sinβ,\r\n                p - e2 * a * cosβ * cosβ * cosβ);\r\n\r\n        // longitude\r\n        var λ = Math.atan2(y, x);\r\n\r\n        // height above ellipsoid (Bowring eqn 7) [not currently used]\r\n        var sinφ = Math.sin(φ), cosφ = Math.cos(φ);\r\n        var ν = a / Math.sqrt(1 - e2 * sinφ * sinφ); // length of the normal terminated by the minor axis\r\n        var h = p * cosφ + z * sinφ - (a * a / ν);\r\n\r\n        var point = new LatLon(φ.toDegrees(), λ.toDegrees(), datum);\r\n\r\n        return point;\r\n    };\r\n\r\n    /**\r\n     * Applies Helmert transform to ‘this’ point using transform parameters t.\r\n     *\r\n     * @private\r\n     * @param {LatLon.datum.transform} t - Transform to apply to this point.\r\n     */\r\n    Vector3d.prototype.applyTransform = function (t) {\r\n        var x1 = this.x, y1 = this.y, z1 = this.z;\r\n\r\n        var tx = t.tx, ty = t.ty, tz = t.tz;\r\n        var rx = (t.rx / 3600).toRadians(); // normalise seconds to radians\r\n        var ry = (t.ry / 3600).toRadians(); // normalise seconds to radians\r\n        var rz = (t.rz / 3600).toRadians(); // normalise seconds to radians\r\n        var s1 = t.s / 1e6 + 1;             // normalise ppm to (s+1)\r\n\r\n        // apply transform\r\n        var x2 = tx + x1 * s1 - y1 * rz + z1 * ry;\r\n        var y2 = ty + x1 * rz + y1 * s1 - z1 * rx;\r\n        var z2 = tz - x1 * ry + y1 * rx + z1 * s1;\r\n\r\n        var point = new Vector3d(x2, y2, z2);\r\n\r\n        return point;\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or\r\n     * degrees+minutes+seconds.\r\n     *\r\n     * @param   {string} [format=dms] - Format point as 'd', 'dm', 'dms'.\r\n     * @param   {number} [dp=0|2|4] - Number of decimal places to use - default 0 for dms, 2 for dm, 4 for d.\r\n     * @returns {string} Comma-separated latitude/longitude.\r\n     */\r\n    LatLon.prototype.toString = function (format, dp) {\r\n        return Dms.toLat(this.lat, format, dp) + ', ' + Dms.toLon(this.lon, format, dp);\r\n    };\r\n\r\n\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n    /** Extend Number object with method to convert numeric degrees to radians */\r\n    if (Number.prototype.toRadians === undefined) {\r\n        Number.prototype.toRadians = function () {\r\n            return this * Math.PI / 180;\r\n        };\r\n    }\r\n\r\n    /** Extend Number object with method to convert radians to numeric (signed) degrees */\r\n    if (Number.prototype.toDegrees === undefined) {\r\n        Number.prototype.toDegrees = function () {\r\n            return this * 180 / Math.PI;\r\n        };\r\n    }\r\n\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n    if (typeof module != 'undefined' && module.exports) module.exports = LatLon; // CommonJS (Node)\r\n    if (typeof module != 'undefined' && module.exports) module.exports.Vector3d = Vector3d; // CommonJs (Node)\r\n    if (typeof define == 'function' && define.amd) define([], function () {\r\n        return LatLon;\r\n    }); // AMD\r\n    if (typeof define == 'function' && define.amd) define([], function () {\r\n        return Vector3d;\r\n    }); // AMD??\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n    /* Vincenty Direct and Inverse Solution of Geodesics on the Ellipsoid (c) Chris Veness 2002-2015  */\r\n    /*                                                                                   MIT Licence  */\r\n    /*                                                                                                */\r\n    /* from: T Vincenty, \"Direct and Inverse Solutions of Geodesics on the Ellipsoid with application */\r\n    /*       of nested equations\", Survey Review, vol XXIII no 176, 1975                              */\r\n    /*       http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf                                             */\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n    'use strict';\r\n    if (typeof module != 'undefined' && module.exports) var LatLon = require('./latlon-ellipsoidal.js'); // CommonJS (Node)\r\n\r\n\r\n    /**\r\n     * Direct and inverse solutions of geodesics on the ellipsoid using Vincenty formulae\r\n     */\r\n\r\n\r\n    /**\r\n     * Returns the distance between ‘this’ point and destination point along a geodesic, using Vincenty\r\n     * inverse solution.\r\n     *\r\n     * @param   {LatLon} point - Latitude/longitude of destination point.\r\n     * @returns (Number} Distance in metres between points or NaN if failed to converge.\r\n     *\r\n     * @example\r\n     *   var p1 = new LatLon(50.06632, -5.71475), p2 = new LatLon(58.64402, -3.07009);\r\n     *   var d = p1.distanceTo(p2); // d: 969954.166\r\n     */\r\n    LatLon.prototype.distanceTo = function (point) {\r\n        if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n        try {\r\n            return this.inverse(point).distance;\r\n        } catch (e) {\r\n            return NaN; // failed to converge\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns the initial bearing (forward azimuth) to travel along a geodesic from ‘this’ point to the\r\n     * specified point, using Vincenty inverse solution.\r\n     *\r\n     * @param   {LatLon} point - Latitude/longitude of destination point.\r\n     * @returns {number}  initial Bearing in degrees from north (0°..360°) or NaN if failed to converge.\r\n     *\r\n     * @example\r\n     *   var p1 = new LatLon(50.06632, -5.71475), p2 = new LatLon(58.64402, -3.07009);\r\n     *   var b1 = p1.initialBearingTo(p2); // b1.toFixed(4): 9.1419\r\n     */\r\n    LatLon.prototype.initialBearingTo = function (point) {\r\n        if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n        try {\r\n            return this.inverse(point).initialBearing;\r\n        } catch (e) {\r\n            return NaN; // failed to converge\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns the final bearing (reverse azimuth) having travelled along a geodesic from ‘this’ point\r\n     * to the specified point, using Vincenty inverse solution.\r\n     *\r\n     * @param   {LatLon} point - Latitude/longitude of destination point.\r\n     * @returns {number}  Initial bearing in degrees from north (0°..360°) or NaN if failed to converge.\r\n     *\r\n     * @example\r\n     *   var p1 = new LatLon(50.06632, -5.71475), p2 = new LatLon(58.64402, -3.07009);\r\n     *   var b2 = p1.finalBearingTo(p2); // b2.toFixed(4): 11.2972\r\n     */\r\n    LatLon.prototype.finalBearingTo = function (point) {\r\n        if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n        try {\r\n            return this.inverse(point).finalBearing;\r\n        } catch (e) {\r\n            return NaN; // failed to converge\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns the destination point having travelled the given distance along a geodesic given by\r\n     * initial bearing from ‘this’ point, using Vincenty direct solution.\r\n     *\r\n     * @param   {number} distance - Distance travelled along the geodesic in metres.\r\n     * @param   {number} initialBearing - Initial bearing in degrees from north.\r\n     * @returns {LatLon} Destination point.\r\n     *\r\n     * @example\r\n     *   var p1 = new LatLon(-37.95103, 144.42487);\r\n     *   var p2 = p1.destinationPoint(54972.271, 306.86816); // p2.toString(): 37.6528°S, 143.9265°E\r\n     */\r\n    LatLon.prototype.destinationPoint = function (distance, initialBearing) {\r\n        return this.direct(Number(distance), Number(initialBearing)).point;\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns the final bearing (reverse azimuth) having travelled along a geodesic given by initial\r\n     * bearing for a given distance from ‘this’ point, using Vincenty direct solution.\r\n     *\r\n     * @param   {number} distance - Distance travelled along the geodesic in metres.\r\n     * @param   {LatLon} initialBearing - Initial bearing in degrees from north.\r\n     * @returns {number} Final bearing in degrees from north (0°..360°).\r\n     *\r\n     * @example\r\n     *   var p1 = new LatLon(-37.95103, 144.42487);\r\n     *   var b2 = p1.finalBearingOn(306.86816, 54972.271); // b2.toFixed(4): 307.1736\r\n     */\r\n    LatLon.prototype.finalBearingOn = function (distance, initialBearing) {\r\n        return this.direct(Number(distance), Number(initialBearing)).finalBearing;\r\n    };\r\n\r\n\r\n    /**\r\n     * Vincenty direct calculation.\r\n     *\r\n     * @private\r\n     * @param   {number} distance - Distance along bearing in metres.\r\n     * @param   {number} initialBearing - Initial bearing in degrees from north.\r\n     * @returns (Object} Object including point (destination point), finalBearing.\r\n     * @throws  {Error}  If formula failed to converge.\r\n     */\r\n    LatLon.prototype.direct = function (distance, initialBearing) {\r\n        var φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();\r\n        var α1 = initialBearing.toRadians();\r\n        var s = distance;\r\n\r\n        var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b, f = this.datum.ellipsoid.f;\r\n\r\n        var sinα1 = Math.sin(α1);\r\n        var cosα1 = Math.cos(α1);\r\n\r\n        var tanU1 = (1 - f) * Math.tan(φ1), cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1;\r\n        var σ1 = Math.atan2(tanU1, cosα1);\r\n        var sinα = cosU1 * sinα1;\r\n        var cosSqα = 1 - sinα * sinα;\r\n        var uSq = cosSqα * (a * a - b * b) / (b * b);\r\n        var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\r\n        var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\r\n\r\n        var cos2σM, sinσ, cosσ, Δσ;\r\n\r\n        var σ = s / (b * A), σʹ, iterations = 0;\r\n        do {\r\n            cos2σM = Math.cos(2 * σ1 + σ);\r\n            sinσ = Math.sin(σ);\r\n            cosσ = Math.cos(σ);\r\n            Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -\r\n                    B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));\r\n            σʹ = σ;\r\n            σ = s / (b * A) + Δσ;\r\n        } while (Math.abs(σ - σʹ) > 1e-12 && ++iterations < 200);\r\n        if (iterations >= 200) throw new Error('Formula failed to converge'); // not possible?\r\n\r\n        var x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\r\n        var φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - f) * Math.sqrt(sinα * sinα + x * x));\r\n        var λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\r\n        var C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));\r\n        var L = λ - (1 - C) * f * sinα *\r\n                (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));\r\n        var λ2 = (λ1 + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI;  // normalise to -180...+180\r\n\r\n        var α2 = Math.atan2(sinα, -x);\r\n        α2 = (α2 + 2 * Math.PI) % (2 * Math.PI); // normalise to 0...360\r\n\r\n        return {\r\n            point: new LatLon(φ2.toDegrees(), λ2.toDegrees(), this.datum),\r\n            finalBearing: α2.toDegrees(),\r\n        };\r\n    };\r\n\r\n\r\n    /**\r\n     * Vincenty inverse calculation.\r\n     *\r\n     * @private\r\n     * @param   {LatLon} point - Latitude/longitude of destination point.\r\n     * @returns {Object} Object including istance, initialBearing, finalBearing.\r\n     * @throws  {Error}  If formula failed to converge.\r\n     */\r\n    LatLon.prototype.inverse = function (point) {\r\n        var p1 = this, p2 = point;\r\n        var φ1 = p1.lat.toRadians(), λ1 = p1.lon.toRadians();\r\n        var φ2 = p2.lat.toRadians(), λ2 = p2.lon.toRadians();\r\n\r\n        var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b, f = this.datum.ellipsoid.f;\r\n\r\n        var L = λ2 - λ1;\r\n        var tanU1 = (1 - f) * Math.tan(φ1), cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1;\r\n        var tanU2 = (1 - f) * Math.tan(φ2), cosU2 = 1 / Math.sqrt((1 + tanU2 * tanU2)), sinU2 = tanU2 * cosU2;\r\n\r\n        var sinλ, cosλ, sinSqσ, sinσ, cosσ, σ, sinα, cosSqα, cos2σM, C;\r\n\r\n        var λ = L, λʹ, iterations = 0;\r\n        do {\r\n            sinλ = Math.sin(λ);\r\n            cosλ = Math.cos(λ);\r\n            sinSqσ = (cosU2 * sinλ) * (cosU2 * sinλ) + (cosU1 * sinU2 - sinU1 * cosU2 * cosλ) * (cosU1 * sinU2 - sinU1 * cosU2 * cosλ);\r\n            sinσ = Math.sqrt(sinSqσ);\r\n            if (sinσ == 0) return 0;  // co-incident points\r\n            cosσ = sinU1 * sinU2 + cosU1 * cosU2 * cosλ;\r\n            σ = Math.atan2(sinσ, cosσ);\r\n            sinα = cosU1 * cosU2 * sinλ / sinσ;\r\n            cosSqα = 1 - sinα * sinα;\r\n            cos2σM = cosσ - 2 * sinU1 * sinU2 / cosSqα;\r\n            if (isNaN(cos2σM)) cos2σM = 0;  // equatorial line: cosSqα=0 (§6)\r\n            C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));\r\n            λʹ = λ;\r\n            λ = L + (1 - C) * f * sinα * (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));\r\n        } while (Math.abs(λ - λʹ) > 1e-12 && ++iterations < 200);\r\n        if (iterations >= 200) throw new Error('Formula failed to converge');\r\n\r\n        var uSq = cosSqα * (a * a - b * b) / (b * b);\r\n        var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\r\n        var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\r\n        var Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -\r\n                B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));\r\n\r\n        var s = b * A * (σ - Δσ);\r\n\r\n        var α1 = Math.atan2(cosU2 * sinλ, cosU1 * sinU2 - sinU1 * cosU2 * cosλ);\r\n        var α2 = Math.atan2(cosU1 * sinλ, -sinU1 * cosU2 + cosU1 * sinU2 * cosλ);\r\n\r\n        α1 = (α1 + 2 * Math.PI) % (2 * Math.PI); // normalise to 0...360\r\n        α2 = (α2 + 2 * Math.PI) % (2 * Math.PI); // normalise to 0...360\r\n\r\n        s = Number(s.toFixed(3)); // round to 1mm precision\r\n        return {distance: s, initialBearing: α1.toDegrees(), finalBearing: α2.toDegrees()};\r\n    };\r\n\r\n\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n    /** Extend Number object with method to convert numeric degrees to radians */\r\n    if (Number.prototype.toRadians === undefined) {\r\n        Number.prototype.toRadians = function () {\r\n            return this * Math.PI / 180;\r\n        };\r\n    }\r\n\r\n    /** Extend Number object with method to convert radians to numeric (signed) degrees */\r\n    if (Number.prototype.toDegrees === undefined) {\r\n        Number.prototype.toDegrees = function () {\r\n            return this * 180 / Math.PI;\r\n        };\r\n    }\r\n\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n    if (typeof module != 'undefined' && module.exports) module.exports = LatLon; // CommonJS (Node)\r\n    if (typeof define == 'function' && define.amd) define([], function () {\r\n        return LatLon;\r\n    }); // AMD\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n    /*  Vector handling functions                           (c) Chris Veness 2011-2015 / MIT Licence  */\r\n    /*                                                                                                */\r\n    /*  These are generic 3-d vector manipulation routines.                                           */\r\n    /*                                                                                                */\r\n    /*  In a geodesy context, these may be used to represent:                                         */\r\n    /*   - n-vector representing a normal to point on Earth's surface                                 */\r\n    /*   - earth-centered, earth fixed vector (= n-vector for spherical model)                        */\r\n    /*   - great circle normal to vector                                                              */\r\n    /*   - motion vector on Earth's surface                                                           */\r\n    /*   - etc                                                                                        */\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Creates a 3-d vector.\r\n     *\r\n     * The vector may be normalised, or use x/y/z values for eg height relative to the sphere or\r\n     * ellipsoid, distance from earth centre, etc.\r\n     *\r\n     * @classdesc Tools for manipulating 3-d vectors, to support various latitude/longitude functions.\r\n     *\r\n     * @constructor\r\n     * @param {number} x - X component of vector.\r\n     * @param {number} y - Y component of vector.\r\n     * @param {number} z - Z component of vector.\r\n     */\r\n    function Vector3d(x, y, z) {\r\n        // allow instantiation without 'new'\r\n        if (!(this instanceof Vector3d)) return new Vector3d(x, y, z);\r\n\r\n        this.x = Number(x);\r\n        this.y = Number(y);\r\n        this.z = Number(z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Adds supplied vector to ‘this’ vector.\r\n     *\r\n     * @param   {Vector3d} v - Vector to be added to this vector.\r\n     * @returns {Vector3d} Vector representing sum of this and v.\r\n     */\r\n    Vector3d.prototype.plus = function (v) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n\r\n        return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);\r\n    };\r\n\r\n\r\n    /**\r\n     * Subtracts supplied vector from ‘this’ vector.\r\n     *\r\n     * @param   {Vector3d} v - Vector to be subtracted from this vector.\r\n     * @returns {Vector3d} Vector representing difference between this and v.\r\n     */\r\n    Vector3d.prototype.minus = function (v) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n\r\n        return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);\r\n    };\r\n\r\n\r\n    /**\r\n     * Multiplies ‘this’ vector by a scalar value.\r\n     *\r\n     * @param   {number}   x - Factor to multiply this vector by.\r\n     * @returns {Vector3d} Vector scaled by x.\r\n     */\r\n    Vector3d.prototype.times = function (x) {\r\n        x = Number(x);\r\n\r\n        return new Vector3d(this.x * x, this.y * x, this.z * x);\r\n    };\r\n\r\n\r\n    /**\r\n     * Divides ‘this’ vector by a scalar value.\r\n     *\r\n     * @param   {number}   x - Factor to divide this vector by.\r\n     * @returns {Vector3d} Vector divided by x.\r\n     */\r\n    Vector3d.prototype.dividedBy = function (x) {\r\n        x = Number(x);\r\n\r\n        return new Vector3d(this.x / x, this.y / x, this.z / x);\r\n    };\r\n\r\n\r\n    /**\r\n     * Multiplies ‘this’ vector by the supplied vector using dot (scalar) product.\r\n     *\r\n     * @param   {Vector3d} v - Vector to be dotted with this vector.\r\n     * @returns {number} Dot product of ‘this’ and v.\r\n     */\r\n    Vector3d.prototype.dot = function (v) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n\r\n        return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    };\r\n\r\n\r\n    /**\r\n     * Multiplies ‘this’ vector by the supplied vector using cross (vector) product.\r\n     *\r\n     * @param   {Vector3d} v - Vector to be crossed with this vector.\r\n     * @returns {Vector3d} Cross product of ‘this’ and v.\r\n     */\r\n    Vector3d.prototype.cross = function (v) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n\r\n        var x = this.y * v.z - this.z * v.y;\r\n        var y = this.z * v.x - this.x * v.z;\r\n        var z = this.x * v.y - this.y * v.x;\r\n\r\n        return new Vector3d(x, y, z);\r\n    };\r\n\r\n\r\n    /**\r\n     * Negates a vector to point in the opposite direction\r\n     *\r\n     * @returns {Vector3d} Negated vector.\r\n     */\r\n    Vector3d.prototype.negate = function () {\r\n        return new Vector3d(-this.x, -this.y, -this.z);\r\n    };\r\n\r\n\r\n    /**\r\n     * Length (magnitude or norm) of ‘this’ vector\r\n     *\r\n     * @returns {number} Magnitude of this vector.\r\n     */\r\n    Vector3d.prototype.length = function () {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n    };\r\n\r\n\r\n    /**\r\n     * Normalizes a vector to its unit vector\r\n     * – if the vector is already unit or is zero magnitude, this is a no-op.\r\n     *\r\n     * @returns {Vector3d} Normalised version of this vector.\r\n     */\r\n    Vector3d.prototype.unit = function () {\r\n        var norm = this.length();\r\n        if (norm == 1) return this;\r\n        if (norm == 0) return this;\r\n\r\n        var x = this.x / norm;\r\n        var y = this.y / norm;\r\n        var z = this.z / norm;\r\n\r\n        return new Vector3d(x, y, z);\r\n    };\r\n\r\n\r\n    /**\r\n     * Calculates the angle between ‘this’ vector and supplied vector.\r\n     *\r\n     * @param   {Vector3d} v\r\n     * @param   {Vector3d} [vSign] - If supplied (and out of plane of this and v), angle is signed +ve if\r\n     *     this->v is clockwise looking along vSign, -ve in opposite direction (otherwise unsigned angle).\r\n     * @returns {number} Angle (in radians) between this vector and supplied vector.\r\n     */\r\n    Vector3d.prototype.angleTo = function (v, vSign) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n\r\n        var sinθ = this.cross(v).length();\r\n        var cosθ = this.dot(v);\r\n\r\n        if (vSign !== undefined) {\r\n            if (!(vSign instanceof Vector3d)) throw new TypeError('vSign is not Vector3d object');\r\n            // use vSign as reference to get sign of sinθ\r\n            sinθ = this.cross(v).dot(vSign) < 0 ? -sinθ : sinθ;\r\n        }\r\n\r\n        return Math.atan2(sinθ, cosθ);\r\n    };\r\n\r\n\r\n    /**\r\n     * Rotates ‘this’ point around an axis by a specified angle.\r\n     *\r\n     * @param   {Vector3d} axis - The axis being rotated around.\r\n     * @param   {number}   theta - The angle of rotation (in radians).\r\n     * @returns {Vector3d} The rotated point.\r\n     */\r\n    Vector3d.prototype.rotateAround = function (axis, theta) {\r\n        if (!(axis instanceof Vector3d)) throw new TypeError('axis is not Vector3d object');\r\n\r\n        // en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\r\n        // en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\r\n        var p1 = this.unit();\r\n        var p = [p1.x, p1.y, p1.z]; // the point being rotated\r\n        var a = axis.unit();          // the axis being rotated around\r\n        var s = Math.sin(theta);\r\n        var c = Math.cos(theta);\r\n        // quaternion-derived rotation matrix\r\n        var q = [\r\n            [a.x * a.x * (1 - c) + c, a.x * a.y * (1 - c) - a.z * s, a.x * a.z * (1 - c) + a.y * s],\r\n            [a.y * a.x * (1 - c) + a.z * s, a.y * a.y * (1 - c) + c, a.y * a.z * (1 - c) - a.x * s],\r\n            [a.z * a.x * (1 - c) - a.y * s, a.z * a.y * (1 - c) + a.x * s, a.z * a.z * (1 - c) + c],\r\n        ];\r\n        // multiply q × p\r\n        var qp = [0, 0, 0];\r\n        for (var i = 0; i < 3; i++) {\r\n            for (var j = 0; j < 3; j++) {\r\n                qp[i] += q[i][j] * p[j];\r\n            }\r\n        }\r\n        var p2 = new Vector3d(qp[0], qp[1], qp[2]);\r\n        return p2;\r\n        // qv en.wikipedia.org/wiki/Rodrigues'_rotation_formula...\r\n    };\r\n\r\n\r\n    /**\r\n     * String representation of vector.\r\n     *\r\n     * @param   {number} [precision=3] - Number of decimal places to be used.\r\n     * @returns {string} Vector represented as [x,y,z].\r\n     */\r\n    Vector3d.prototype.toString = function (precision) {\r\n        var p = (precision === undefined) ? 3 : Number(precision);\r\n\r\n        var str = '[' + this.x.toFixed(p) + ',' + this.y.toFixed(p) + ',' + this.z.toFixed(p) + ']';\r\n\r\n        return str;\r\n    };\r\n\r\n\r\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n    if (typeof module != 'undefined' && module.exports) module.exports = Vector3d; // CommonJS (Node)\r\n    if (typeof define == 'function' && define.amd) define([], function () {\r\n        return Vector3d;\r\n    }); // AMD\r\n    /**\r\n     * (c) Abid Mohammed 2015\r\n     * Apache Licence\r\n     *\r\n     *Usage - To convert an array of LatLons X into an array of LatLons Y such that all LatLons in Y are at a Distance D(fineDistance) from each other.\r\n     *\r\n     */\r\n    'use strict';\r\n    if (typeof module != 'undefined' && module.exports) var LatLon = require('./latlon-ellipsoidal.js'); // CommonJS (Node)\r\n\r\n    function CalculateFinerLatLngs(latlons, fineDistance) {\r\n        var fineShapePoints = [];\r\n        fineShapePoints.push(latlons[0]);\r\n        for (var i = 1; i < latlons.length; i++) {\r\n            var distanceBetweenLatLon = latlons[i - 1].distanceTo(latlons[i]);\r\n            var bearingBetweenLatLon = latlons[i - 1].initialBearingTo(latlons[i]);\r\n            if (distanceBetweenLatLon <= fineDistance) {\r\n                fineShapePoints.push(latlons[i]);\r\n            } else {\r\n                var div = 1;\r\n                var remainingDist = distanceBetweenLatLon;\r\n                while (remainingDist >= 0) {\r\n                    var toD = div++ * fineDistance;\r\n                    if (remainingDist - fineDistance >= 0) {\r\n                        var nextPoint = latlons[i - 1].direct(toD, bearingBetweenLatLon);\r\n                        fineShapePoints.push(nextPoint);\r\n                    } else {\r\n                        fineShapePoints.push(latlons[i]);\r\n                    }\r\n                    remainingDist = remainingDist - fineDistance;\r\n                }\r\n            }\r\n        }\r\n        return fineShapePoints;\r\n    }\r\n    /**\r\n     * (c) Abid Mohammed 2015\r\n     *  Apache Licence\r\n     **/\r\n\r\n    function msToHours(ms) {\r\n        var seconds = ms / 1000;\r\n        var hours = parseInt(seconds / 3600);\r\n        seconds = seconds % 3600;\r\n        var minutes = (seconds / 60);\r\n        var result = hours + (minutes / 60);\r\n        return result;\r\n    }\r\n\r\n    function calcSpeed(dist, time_in_msec) {\r\n        return dist / msToHours(time_in_msec);\r\n    }\r\n\r\n    function calcTimeInMilliSec(speed, distance) {\r\n        return (distance / speed) * 60 * 60 * 1000;\r\n    }\r\n\r\n    function calcDistTravelled(speed, time_in_msec) {\r\n        return speed * msToHours(time_in_msec);\r\n    }\r\n\r\n    function createVehicleMarkerCanvas(elementId) {\r\n        var vehicleMarkerCanvas = document.getElementById(elementId);\r\n        var vMarkerContext = vehicleMarkerCanvas.getContext('2d');\r\n        vMarkerContext.beginPath();\r\n        vMarkerContext.shadowColor = '#0080FF';\r\n        vMarkerContext.shadowOffsetX = 0;\r\n        vMarkerContext.shadowOffsetY = 0;\r\n        vMarkerContext.shadowBlur = 6;\r\n        vMarkerContext.arc(vehicleMarkerCanvas.width / 2, vehicleMarkerCanvas.height / 2, 8, 0, 2 * Math.PI, false);\r\n        vMarkerContext.fillStyle = '#2ECCFA';\r\n        vMarkerContext.fill();\r\n        vMarkerContext.lineWidth = 1.5;\r\n        vMarkerContext.strokeStyle = 'white';\r\n        vMarkerContext.stroke();\r\n        return vehicleMarkerCanvas;\r\n    }\r\n\r\n    function convertRouteIntoFinerLatLngs(route, fineDist) {\r\n        var latlongs = convertRouteToLatLngObjects(route);\r\n        return CalculateFinerLatLngs(latlongs, fineDist);\r\n    }\r\n\r\n    function convertRouteToLatLngObjects(route) {\r\n        var latlongs = [];\r\n        route.shape.forEach(function (point) {\r\n            var p = point.split(\",\");\r\n            latlongs.push(new LatLon(p[0], p[1]));\r\n        });\r\n        return latlongs;\r\n    }\r\n\r\n</script>\r\n</body>\r\n</html>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}